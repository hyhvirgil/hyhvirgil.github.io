# 德布鲁因序列




## 德布鲁因序列

### 定义

德布鲁因序列（De Bruijn Sequences），记为 $ B(k, n) $，是 k 元素构成的循环序列。所有长度为 n 的 k 元素构成序列都在它的子序列（以环状形式）中，出现并且仅出现一次。

例如，序列 00010111 属于 $ B(2,3) $。 00010111 的所有长度为 3 的子序列为000,001,010,101,011,111,110,100，正好构成了 {0,1} 长度为 3 的所有组合，且都出现了一次。



### 长度

德布鲁因序列的长度为 $ k^n $。在上述 $ B(2,3)  $ 的例子中，总长度为 $ 2^3=8 $ 。

注意到，所有长度为 n 的 k 元素构成的序列总共有 $ k^n $。而对于德布鲁因序列中的每个元素，恰好构成一个以此元素开头长度为 n 的子序列。所以德布鲁因序列的长度为 $ k^n $。



### 数量

德布鲁因序列不是唯一的，所以在众多开源代码中，经常会见到使用不同的序列值进行计算。虽然所用的序列值不一样，但思想和效果都是一样的。

<br>



## 应用实例

### 位扫描器

有这么一个常见的问题，对一个非 0 的正数，如果快速地找到它二进制位中最低位的 1 的位置呢？例如，0101010010010100，它的最低位的 1 的位置是从右往左数的第 2 位（从 0 开始数）。

这个问题，可以从右往左遍历每一位上的值，发现首个 1 时，其下标，即是我们要的结果。那有没有效率更高的做法呢？

<br/>

这有两个理论需要说明下：

#### 隔离 1

我们首先将在任意二进制值中找到 1 的问题简化为在恰好包含一个 1 的值中找到 1 的问题。

如果（非零）输入字是 x，我们计算 `y = x & (-x)`（"＆"是按位 AND 的 C 语法），它产生的值 y 仅包含唯一且是 x 的最低位 1。例如，如果 `x = 01101000`，则 x 的二进制补码为 `-x = 10011000`，因此 `y =00001000`。

{{< admonition tip >}}

要索引一个值中的所有1，我们可以计算 x-y，从而删除已经索引的位，然后重复该过程。

{{< /admonition >}}

隔离 1 的这种策略似乎是大家的共识，因为在当代机器下，按位与和二进制补码是可以在一个机器周期内完成的。

#### 哈希

现在，我们剩下的问题是在正好包含一个 1 的值中索引 1 。对于一个 n 位的值，有正好 n 个可能的值正好包含一个 1。因为 n 很小[^2]，我们可以使用算法中的另一个技巧：哈希。

我们使用完美的哈希函数[^3] h 将每个单 1 值映射到哈希表。然后，给定正好包含一个 1 的值 x，我们看一下
哈希表中存储 1 位索引的 h（x）上的 h（x）。为了使该策略有效地起作用，我们需要：

-   哈希表很小
-   哈希函数易于计算
-   并且散列函数不产生冲突，即，两个单一的 1 值 x 和 y 都不应产生哈希值，使得h（x）= h（y）。如 x = 001000000, y = 00010000 时，h（x）必须不等于 h（y）



#### 例子

下面看下 go 源码中是如何解决的。

<br/>

在 go 内存管理的相关源码中，有使用 `allocCache uint64` 变量的二进制位来表示相同大小的内存块是否已经分配，即 1 表示未分配，0 表示已分配。那么当需要分配内存时，只要找出其中一个 1，把对应位置的 1 设置为 0。并把对应位置的指针返回即可。

{{< admonition tip >}}

初始化代码如下：

```go
s.allocCache = ^uint64(0) // all 1s indicating all free.
```

{{< /admonition >}}



那么，如何找出 1 的位置呢？

```go E:\Program Files (x86)\go\src\runtime\internal\sys\intrinsics.go
// 摘自：runtime\internal\sys\intrinsics.go
// 由于 32 位和 64 位思路是一致的，此处选择 32 位说明
const deBruijn32 = 0x04653adf

var deBruijnIdx32 = [32]byte{
	0, 1, 2, 6, 3, 11, 7, 16,
	4, 14, 12, 21, 8, 23, 17, 26,
	31, 5, 10, 15, 13, 20, 22, 25,
	30, 9, 19, 24, 29, 18, 28, 27,
}

func Ctz32(x uint32) int {
	x &= -x                      // isolate low-order bit
	y := x * deBruijn32 >> 27    // extract part of deBruijn sequence
	i := int(deBruijnIdx32[y])   // convert to bit index

    ...
}
```

通过上述概念可以了解到，对于 32 位的值，由于$ 2^5=32 $，所以应记为 B(2, 5)，即子序列长度为 5。

我们以序列 `deBruijn32 = 0x04653adf = 00000100 01100101 00111010 11011111` 来分析：

```
00000100 01100101 00111010 11011111     子序列值 1的位置
00000... ........ ........ ........     0		0
.00001.. ........ ........ ........     1	    1
..00010. ........ ........ ........     2	    2
...00100 ........ ........ ........     4	    3
....0100 0....... ........ ........     8	    4
.....100 01...... ........ ........     17	    5
......00 011..... ........ ........     3	    6
.......0 0110.... ........ ........     6	    7
........ 01100... ........ ........     12	    8
........ .11001.. ........ ........     25	    9
........ ..10010. ........ ........     18	    10
........ ...00101 ........ ........     5	    11
........ ....0101 0....... ........     10	    12
........ .....101 00...... ........     20	    13
........ ......01 001..... ........     9	    14
........ .......1 0011.... ........     19	    15
........ ........ 00111... ........     7	    16
........ ........ .01110.. ........     14	    17
........ ........ ..11101. ........     29	    18
........ ........ ...11010 ........     26	    19
........ ........ ....1010 1.......     21	    20
........ ........ .....010 11......     11	    21
........ ........ ......10 110.....     22	    22
........ ........ .......0 1101....     13	    23
........ ........ ........ 11011...     27	    24
........ ........ ........ .10111..     23	    25
........ ........ ........ ..01111.     15	    26
........ ........ ........ ...11111     31	    27
........ ........ ........ ....11110    30	    28
........ ........ ........ .....11100   28	    29
........ ........ ........ ......11000  24	    30
........ ........ ........ .......10000 16	    31
```

假设入参时：x = 00000000 00000000 10100111 00010000



根据**隔离 1**一小节中 `x &= -x` 的含义。运行此语句后 x = 00000000 00000000 00000000 00010000

<br>

此时 x 只剩下其中一位是 1，其它都是 0。换句话说，现在 x 必定是 2 的 n 次方，所以任何一个数字乘以这个特殊的二进制的数，都相当于左移运算。左移的位数就是原二进制数末尾 1 所在的位置。即 x * deBruijn32 = deBruijn32 向左移 4 位 = 0100 01100101 00111010 11011111 0000

紧接着再向右移 27 位，那 deBruijn32 中的值只留下 5 位，且这 5 位是根据 x 中 1 的搁置决定的。 即 y = x * deBruijn32 >> 27 = 01000 = 8。



再根据 deBruijnIdx32  数组中事先计算好的值和位置的关系，就可以计算出，deBruijnIdx32 [8] = 4。即 1 在入参时 x 的位置是 4。

{{< admonition tip >}}

var deBruijnIdx32 = [32]byte{
	0, 1, 2, 6, 3, 11, 7, 16,
	4, 14, 12, 21, 8, 23, 17, 26,
	31, 5, 10, 15, 13, 20, 22, 25,
	30, 9, 19, 24, 29, 18, 28, 27,
}

deBruijnIdx32 数组是如何计算出的呢？

先看上述 0x04653adf 的"子序列值"与 "1 的位置"关系。

当子序列为 100 01，"子序列值"为 17 时，"1 的位置"为 5。这时，设置 deBruijnIdx32[17] = 5 即可。

{{< /admonition >}}



## 延伸阅读

*   <http://supertech.csail.mit.edu/papers/debruijn.pdf>



[^2]: 如 32 位值 n 为32，64 位值 n 为 64。都是很小且可以枚举的值
[^3]: https://www.wiki-wiki.top/baike-%E5%AE%8C%E7%BE%8E%E6%95%A3%E5%88%97



